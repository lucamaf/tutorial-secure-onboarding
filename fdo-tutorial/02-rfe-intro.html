<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RHEL OSTree images - Intro :: Secure Edge device onboarding with RHEL and FDO</title>
    <link rel="canonical" href="https://luisarizmendi.github.io/tutorial-secure-onboarding/fdo-tutorial/02-rfe-intro.html">
    <link rel="prev" href="01-fdo-lab.html">
    <link rel="next" href="02-rfe-lab.html">
    <meta name="generator" content="Antora 3.0.0">
    <link rel="stylesheet" href="../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://developers.redhat.com" target="_blank"><img src="../_/img/NewRHDFullLogo_4-color_white-wordmark.png" height="40px" alt="Red Hat Developer Program"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="https://luisarizmendi.github.io/tutorial-secure-onboarding">Secure Edge device onboarding with RHEL and FDO</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://developers.redhat.com/ebooks/" target="_blank">Books</a>
        <a class="navbar-item" href="https://developers.redhat.com/cheatsheets/" target="_blank">Cheat Sheets</a>
        <a class="navbar-item" href="https://developers.redhat.com/events/" target="_blank">Upcoming Events</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">More Tutorials</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://redhat-developer-demos.github.io/kubernetes-tutorial/" target="_blank">Kubernetes</a>
            <a class="navbar-item" href="https://redhat-developer-demos.github.io/istio-tutorial/" target="_blank">Istio</a>
            <a class="navbar-item" href="https://redhat-developer-demos.github.io/quarkus-tutorial/" target="_blank">Quarkus</a>
            <a class="navbar-item" href="https://redhat-developer-demos.github.io/knative-tutorial/" target="_blank">Knative</a>
            <a class="navbar-item" href="https://redhat-developer-demos.github.io/tekton-tutorial/" target="_blank">Tekton</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="fdo-tutorial" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html"></a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="00-intro.html">Introduction to secure edge device onboarding</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00-prerequisite.html">0. Lab prerequisites</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-prerequisite.html#virtualization">Prepare your virtualization environment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-prerequisite.html#arch">Choose your lab architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-prerequisite.html#usecase">Create your use case</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="01-fdo-intro.html">1.A FIDO Device Onboarding (FDO) - Intro</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html">1.B FIDO Device Onboarding (FDO) - Lab</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html#fdo-services">FDO services</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-lab.html#fdo-services-aio">Option 1: All-in-one FDO server installation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-lab.html#fdo-services-dedicated">Option 2: Dedicated FDO servers</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html#fdo-config">FDO Service API config</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona">Option A: Creating your own use case</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-user">initial_user</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-files">files</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-commands">commands</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-encrypt">diskencryption_clevis</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optionb">Option B: Using the example use case</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="02-rfe-intro.html">2.A RHEL OSTree images - Intro</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="02-rfe-lab.html">2.B RHEL OSTree images - Lab</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-rfe-lab.html#rfe-imagebuilder">Install Image builder</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="02-rfe-lab.html#rfe-image">Create the RHEL OSTree image</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02-rfe-lab.html#rfe-ostreeimage">Generating the repo image</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02-rfe-lab.html#rfe-publish">Publishing the repo image</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-rfe-lab.html#rfe-iso">Create the RHEL ISO</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03-onboarding.html">3. Edge device onboarding</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-vm">Creating the edge device VM</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-fdoclient">FDO client in action</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-fdoservers">FDO server side</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-checks">Checking the edge device onboard</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="99-summary.html">Summary</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Secure Edge device onboarding with RHEL and FDO</a></li>
    <li><a href="02-rfe-intro.html">2.A RHEL OSTree images - Intro</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/luisarizmendi/tutorial-secure-onboarding/edit/master/documentation/modules/ROOT/pages/02-rfe-intro.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">RHEL OSTree images - Intro</h1>
<div class="paragraph">
<p>A RHEL for Edge image is an rpm-ostree image that includes system packages to remotely install RHEL on Edge servers.</p>
</div>
<div class="paragraph">
<p>The system packages include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Base OS package</p>
</li>
<li>
<p>Podman as the container engine</p>
</li>
<li>
<p>Additional RPM content</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can customize the image to configure the OS content as per your requirements by using either Image Builder installed on a RHEL system or using <a href="http://console.redhat.com">Red Hat Hybrid Console</a>.</p>
</div>
<div class="paragraph">
<p>Working with an OSTree based Operating System has multiple benefits when they are applied to edge computing use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Simplified management</strong>: Secure and scale with the benefits of zero-touch provisioning, fleet health visibility, and quick security remediations throughout the whole lifecycle</p>
</li>
<li>
<p><strong>Platform consistency</strong>: Easily create purpose-built OS images optimized for the architectural challenges inherent at edge. It makes the system more  reliable and predictable.</p>
</li>
<li>
<p><strong>Efficient over-the-air updates</strong>: Updates transfer significantly less data and are ideal for remote sites with limited or intermittent connectivity</p>
</li>
<li>
<p><strong>Unattended resilience</strong>: Application specific health checks detect conflicts and automatically rollback an OS update, preventing downtime</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to know more about OSTree RHEL you can read the article attached below.</p>
</div>
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>A “Git-like” Linux Operating System</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">A “Git-like” Linux Operating System</h1>
</header>
<section data-field="subtitle" class="p-summary">
Probably you are getting their benefits but you don’t even know that you were using them, I’m talking about libostree Operating Systems.
</section>
<section data-field="body" class="e-content">
<section name="d36a" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5a65" id="5a65" class="graf graf--h3 graf--leading graf--title">A “Git-like” Linux Operating System</h3><p name="9cd1" id="9cd1" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Probably you are getting their benefits but you don’t even know that you were using them*, I’m talking about libostree Operating Systems.</em></p><p name="3be7" id="3be7" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">This is the history of how the needs of a group of developers made it possible, using standard Linux features and concepts borrowed from technologies such as Git, to manage a Linux OS lifecycle as if it were a source code repository.</em></p><blockquote name="2f8c" id="2f8c" class="graf graf--blockquote graf-after--p">*If you are using OpenShift, Fedora IoT or <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/composing_installing_and_managing_rhel_for_edge_images/introducing-rhel-for-edge-images_composing-installing-managing-rhel-for-edge-images" data-href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/composing_installing_and_managing_rhel_for_edge_images/introducing-rhel-for-edge-images_composing-installing-managing-rhel-for-edge-images" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">RHEL for Edge</a>, you are using a libostree Linux Operating System, just as an example.</blockquote><figure name="121f" id="121f" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="0*1rmEc4TRAcHFe_gQ" data-width="1000" data-height="665" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/0*1rmEc4TRAcHFe_gQ"><figcaption class="imageCaption">Image from <a href="https://unsplash.com/@eprouzet" data-href="https://unsplash.com/@eprouzet" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Eric Prouzet</a> (unsplash.com)</figcaption></figure><p name="d902" id="d902" class="graf graf--p graf-after--figure">Linux is great.</p><p name="e160" id="e160" class="graf graf--p graf-after--p">Linux is great…but let’s be clear, sometimes its flexibility gives more than one headache when it comes to Operating System lifecycle management.</p><p name="2b46" id="2b46" class="graf graf--p graf-after--p">We tried to overcome the challenges that we find while deploying, patching, upgrading, onboarding, decomissing, observing, recovering, and debugging Linux Operating Systems by using a specific set of tools that get the most from the OS features at the same time that simplifies and amplifies the management operations for our preferred Linux distribution.</p><p name="d057" id="d057" class="graf graf--p graf-after--p">We have tools that standardize the version of the binaries and software installed across multiple systems, tools that patch the OS if a new vulnerability is found, and tools that recover a previous state if something really wrong happens with your Linux, … but what if I tell you that there is an approach to solve these and other lifecycle management challenges? What if I just could manage the different OS lifecycle updates as if they were rooms in your own hotel, where I could sleep in a new one with a different view, bed, or decoration, but where if it does not convince me I could always go back to my preferred one where I feel comfortable and safe?</p><blockquote name="c01f" id="c01f" class="graf graf--blockquote graf-after--p">Note: This is a long article, so I will be nice and I will tell you a secret, at the end of it I’ve included a summary that tries to cover the topic at high-level and outline the benefits of this kind of systems.</blockquote><h3 name="974f" id="974f" class="graf graf--h3 graf-after--blockquote">Why do we need “something” different?</h3><p name="f517" id="f517" class="graf graf--p graf-after--h3">When it comes to technology, sometimes “<em class="markup--em markup--p-em">less is more</em>”. If your smartphone provides a GPS map APP you probably won’t buy a physical GPS navigator. If your Linux can provide effective and easy-to-use out-of-box features, why would you need to configure and maintain any additional tools?</p><p name="bcb7" id="bcb7" class="graf graf--p graf-after--p">Think about the complexity (and cost) of the solutions out there that are promising Operating System rollbacks, incremental updates, OS consistency, or binary change history tracking. Wouldn’t be nice if I could accomplish that with just OS features? Of course, this statement can only be true if the out-of-the-box feature is, at least, as good as the ones provided by additional tooling, but we will see in this article how this new lifecycle management approach can provide these features and more.</p><p name="fef1" id="fef1" class="graf graf--p graf-after--p">You will also see how this “something” different, let’s call it <em class="markup--em markup--p-em">libostree</em> (name <em class="markup--em markup--p-em">OSTree</em> is also used), that started to provide a way to perform a more effective development, brings benefits that are the perfect match to cover the gaps that we find in many other fields, from Edge Computing to Hybrid-cloud use cases.</p><p name="6da5" id="6da5" class="graf graf--p graf-after--p">After that, we will see how common problems of several solution use cases will greatly benefit from the usage of libostree Linux.</p><h3 name="ce64" id="ce64" class="graf graf--h3 graf-after--p">Being in “Jail” is not always a bad thing</h3><p name="4ea8" id="4ea8" class="graf graf--p graf-after--h3">Some years ago, some people were struggling with the complexity of developing using core aspects of the OS without “breaking things”, or at least having a safe way to “break things”. They ended up writing down a set of capabilities that they would like to have implemented to simplify the development (of GNOME) by being able to quickly create a new “instance” of the OS in the same system where they will perform some changes that could be easily reverted… but that will also cover several additional needs, such as sharing data between these multiple “versions” of the OS, using the system installed apps, specific hardware usage, etc…</p><p name="9cca" id="9cca" class="graf graf--p graf-after--p">Getting a new “OS instance” could be accomplished using technologies such as virtualization, containers, etc… but the creation process is slow (ie. create a new VM or building a new container takes some time) and access to the same system data, applications and Hardware is not always easy, along with that the kind of rollback capability that they were looking for was not trivial sometimes. They needed something else.</p><p name="31f2" id="31f2" class="graf graf--p graf-after--p">Based on those core requirements, and after reviewing some alternatives (virtualization, containers, BTRFS,…) they decided that “<em class="markup--em markup--p-em">chroot”</em> could be a good candidate as the foundation of something new that could help with the gaps they found.</p><p name="2e05" id="2e05" class="graf graf--p graf--startsWithDoubleQuote graf-after--p">“C<em class="markup--em markup--p-em">hroot”</em> is an operation that was introduced in the early days of Unix that changes the apparent directory used as “root directory” by the system, making it possible to create a “<em class="markup--em markup--p-em">jail</em>” environment for the applications running on it. It is used to create sandboxes for processes, so they cannot maliciously change data outside the chrooted directory, or as a lightweight substitute for VMs (remember they needed to “<em class="markup--em markup--p-em">quickly create a new OS instance</em>”, so it seems to be a good choice).</p><p name="4a44" id="4a44" class="graf graf--p graf-after--p">It could also sound familiar to “containers”, isn’t it? While the concept is similar, with the container “namespaces” you get additional isolation, which will prevent you to access certain OS resources that you would like to keep sharing… something that you can get when using “chroot jailed environments”.</p><p name="7918" id="7918" class="graf graf--p graf-after--p">Their idea was to make it possible to boot from different chroot directories, so they could potentially develop new features on one jail environment, being able to access some shared data along with other applications and, if they break something, just go back to the “original” chroot jail that wouldn’t be affected by their changes.</p><figure name="efe0" id="efe0" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*E5x-H71-MDNgxzNDsWuZFA.png" data-width="1320" data-height="295" src="https://cdn-images-1.medium.com/max/800/1*E5x-H71-MDNgxzNDsWuZFA.png"><figcaption class="imageCaption">RHEL for Edge chroot directories example</figcaption></figure><p name="376e" id="376e" class="graf graf--p graf-after--figure">But just using <em class="markup--em markup--p-em">chroot</em> was not enough because in order to provide these capabilities you need to make it work with other different bootloader components like GRUB, kernel init files, FS mount, etc… and not just only that, you need to take into account how to perform certain operations such as platform updates… and that’s what <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">libostree</em></strong> is all about.</p><h3 name="7b8b" id="7b8b" class="graf graf--h3 graf-after--p">A “Git-like versioning model” for bootable filesystem</h3><p name="fccd" id="fccd" class="graf graf--p graf-after--h3">If you want to read a formal description of what libostree is you can check how it is described in its own <a href="https://github.com/ostreedev/ostree" data-href="https://github.com/ostreedev/ostree" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">source code repository:</a></p><div name="f4d4" id="f4d4" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://ostreedev.github.io/ostree/" data-href="https://ostreedev.github.io/ostree/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://ostreedev.github.io/ostree/"><strong class="markup--strong markup--mixtapeEmbed-strong">libostree</strong><br><em class="markup--em markup--mixtapeEmbed-em">This project is now known as “libostree”, though it is still appropriate to use the previous name: “OSTree” (or…</em>ostreedev.github.io</a><a href="https://ostreedev.github.io/ostree/" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="a73a99336c631f46d63856987aa81716"></a></div><blockquote name="4588" id="4588" class="graf graf--blockquote graf-after--mixtapeEmbed">Libostree is both a shared library and suite of command line tools that combines a “git-like” model for committing and downloading bootable filesystem trees, along with a layer for deploying them and managing the bootloader configuration.</blockquote><p name="b727" id="b727" class="graf graf--p graf-after--blockquote">In other words, <em class="markup--em markup--p-em">libostree</em> is the missing piece that you need to have and maintain the lifecycle of a complete bootable Operating System based in multiple chroot jail environments… but wait, probably something got your attention, it says that <em class="markup--em markup--p-em">libostree</em> follows a “git-like model”. Why is there that reference?</p><p name="9618" id="9618" class="graf graf--p graf-after--p">Let’s step a little bit back. We have been talking about using <em class="markup--em markup--p-em">chroot</em> to create different “versions” of the root filesystem that could be booted. Those versions will probably have a lot of files that are identical to each other. Coping the same files into each “<em class="markup--em markup--p-em">chroot jail</em>” would consume a lot of space, then there must be another way to have the same files in different root folders but with neither replicating nor sharing them at the same time that you keep track of the version changes.</p><p name="5cac" id="5cac" class="graf graf--p graf-after--p">You might not be an expert in Git, but you probably know a little bit about storage technologies such as Object-based storage concepts and how unstructured data that is stored in a flat data environment can be described by using hash strings, like a key-value data store that binds the hash with the file metadata and finally with the actual data bits. Git works in a similar way.</p><p name="ccc3" id="ccc3" class="graf graf--p graf-after--p">Git is a database of objects identified by hash that are stored using a key-value data store concept. It has 4 different types of objects which identify the content of a file (<em class="markup--em markup--p-em">blob</em>), the directory structure (<em class="markup--em markup--p-em">tree</em>), the “versioning” info (<em class="markup--em markup--p-em">commit</em>), and annotations (<em class="markup--em markup--p-em">tag</em>).</p><p name="d937" id="d937" class="graf graf--p graf-after--p">While “<em class="markup--em markup--p-em">blobs</em>” and “<em class="markup--em markup--p-em">trees</em>” are enough to represent a complete file system, the “<em class="markup--em markup--p-em">commits</em>” contain the reference to the “<em class="markup--em markup--p-em">tree</em>” object describing the root directory of the repository, which provides a full versioning system. Two different versions could point to the same “<em class="markup--em markup--p-em">blob</em>” if the bits between versions didn’t change, which results in not having to replicate the bits between them.</p><p name="648d" id="648d" class="graf graf--p graf-after--p">Git seems the perfect match for what we are looking for, why not use it instead of creating a new git-like “thing” (<em class="markup--em markup--p-em">libostree</em>)?</p><blockquote name="53c8" id="53c8" class="graf graf--blockquote graf-after--p">Note: If you want to check out the libostree objects you can find them here: <a href="https://ostreedev.github.io/ostree/repo/" data-href="https://ostreedev.github.io/ostree/repo/" class="markup--anchor markup--blockquote-anchor" rel="nofollow noopener noopener" target="_blank">https://ostreedev.github.io/ostree/repo/</a></blockquote><p name="2e8e" id="2e8e" class="graf graf--p graf-after--blockquote">I’ve already shared one reason, we need additional specific features to make the versioned filesystem become an actual versioned Linux bootable system (GRUB, init files, etc), but there is something more. Git was designed as a source code repository versioning system, which means that its features are focused on “text files”, in contrast, what we will need is mostly versioning of a mix of “text files” and “binary files” so the features must be optimized for both, not just text. For that reason, <em class="markup--em markup--p-em">libostree</em> is not just Git, it uses Git concepts and applies them in a very similar way, but the implementation is not exactly the same one.</p><h3 name="c660" id="c660" class="graf graf--h3 graf-after--p">File “replicas” without multiplying the space needs</h3><p name="f004" id="f004" class="graf graf--p graf-after--h3">Now that we understood that <em class="markup--em markup--p-em">chroot</em> is the right technology to create the “jailed” root filesystem environments and that we would like to have a versioning system similar to what we get with Git, we need the Linux functionality that glues them together, and that is the file “hard linking”.</p><p name="fd35" id="fd35" class="graf graf--p graf-after--p">In Linux, we have <a href="https://www.redhat.com/sysadmin/linking-linux-explained" data-href="https://www.redhat.com/sysadmin/linking-linux-explained" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">two kinds of file links: soft and hard links</a>. While soft links (symbolic links) are a special kind of file that points to another regular file (which points to the data), hard links are different filenames pointing directly to the same data and attributes (inode).</p><figure name="29e3" id="29e3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*C9W87v7Fg7XPg3xcFCWmJg.png" data-width="1436" data-height="305" src="https://cdn-images-1.medium.com/max/800/1*C9W87v7Fg7XPg3xcFCWmJg.png"><figcaption class="imageCaption">RHEL for Edge /bin/bash hard links to the same inode since there were not changed between deployments</figcaption></figure><p name="8e3b" id="8e3b" class="graf graf--p graf-after--figure">The two different types of links exist because they offer different capabilities. There is a key difference between them that makes hard links better suited for our git-like versioning use case. With hard links, if you delete the “target” file you can still have access to the data, while with soft links if you delete the target file the symbolic link will stop working and become useless. We need to have multiple “file replicas” on the same disk partition, and those replicas must be independent, so when you delete one file you wouldn’t like to “auto-delete” the rest of the “replicas”…</p><p name="05b3" id="05b3" class="graf graf--p graf-after--p">So it’s clear that soft-links are not an option and hard links are the way to go… but there is something else to bear in mind when using hard links…</p><h3 name="ca77" id="ca77" class="graf graf--h3 graf-after--p">You won’t break it if you cannot touch it</h3><p name="ce52" id="ce52" class="graf graf--p graf-after--h3">We have seen how Hard links provide the benefits that we saw, but its usage also has a big implication that we need to address: if you change the content in one hard-link file and so all the remaining file hard links pointing to the same inode will be changed too.</p><p name="a0e1" id="a0e1" class="graf graf--p graf-after--p">Why is that an issue? Imagine that you have two OS “snapshots” (let’s start calling them “deployments”) in your system: deployment A, and deployment B which are identical. While running on version B you change a binary version, but after that change, you realize that something is going wrong and you revert to version A…. the problem is that the same change that you did in deployment B, and which broke the system, is applied to your deployment A too so you won’t get rid of the issue that you created.</p><p name="2431" id="2431" class="graf graf--p graf-after--p">What’s the best solution to solve this problem? Well, actually it’s pretty simple: by default, do not allow to change anything.</p><p name="fe2f" id="fe2f" class="graf graf--p graf-after--p">Instead of allowing file changes like in a regular Operating System, making it necessary to build a complex change tracking system to be sure that any operation that changes a file is recorded to be processed afterward so you can revert it, you could just prevent changes by default and build a way to perform changes only under the control of your versioning system… and <em class="markup--em markup--p-em">libostree</em> was designed around this concept.</p><p name="1bed" id="1bed" class="graf graf--p graf-after--p">In order to prevent the changes, the Operating System is built on top of a read-only filesystem, so it works like an “image snapshot” of the root filesystem of the operating system, but of course, <em class="markup--em markup--p-em">libostree</em> need also to provide a method to perform effective changes to those images.</p><p name="b713" id="b713" class="graf graf--p graf-after--p">When you need to perform one (or a set of) changes, a new replica of the whole root filesystem is created (remember that that does not mean to double disk space needed and that creating that replica is quite fast) and the changes will take place on it. The files that you didn’t touch will remain as hard links, while the modified versions will become a new “regular” file or be deleted as in the example below.</p><figure name="af00" id="af00" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*FkV4F_EiM-0FvYnAzCzjkg.png" data-width="1545" data-height="565" src="https://cdn-images-1.medium.com/max/800/1*FkV4F_EiM-0FvYnAzCzjkg.png"><figcaption class="imageCaption">RHEL for Edge example where zsh was removed in one deployment</figcaption></figure><blockquote name="8bfa" id="8bfa" class="graf graf--blockquote graf-after--figure">Note: deployments can also be deleted to save some disk space, for example in this case if you won’t need zsh anymore you could remove the deployment that contains the binary (but remember that it will only free the size of that binary if that was the only change between deployments, the rest are just hard links)</blockquote><h3 name="0787" id="0787" class="graf graf--h3 graf-after--blockquote">Read-only does not mean do-not-update at all</h3><p name="360f" id="360f" class="graf graf--p graf-after--h3">Let’s say that you have several application binaries that you would like to update, as we have seen, you need to create a new replica of your chroot filesystem with the new versions of the binaries but, how do I use that new replica?</p><p name="df84" id="df84" class="graf graf--p graf-after--p">When you are running in a deployment (remember deployment=filesystem version/revision) and create a new chroot directory with the changes, you are still running on the source version, you don’t instantaneity move to the new deployment… you just made a bunch of new hard links…. How do you make effective these changes to the “running OS”?</p><p name="f445" id="f445" class="graf graf--p graf-after--p">With <em class="markup--em markup--p-em">libostree</em>, at system boot time, one of the available OS root “snapshots/images/deployments” will be selected by following a symbolic link located in a specific place on the filesystem, so if you want to use any alternative root filesystem image (for example, the one with our new binaries) we just need to change the default (0) symbolic link and start pointing to this new filesystem “release”.</p><p name="0564" id="0564" class="graf graf--p graf-after--p">How is that included during the boot process? There is a new kernel argument in the <em class="markup--em markup--p-em">initramfs</em> file specifying the soft-link (which points to the deployment chroot filesystem).</p><figure name="2aba" id="2aba" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dhdPdG9jqmZMe8rlfBUfFQ.png" data-width="1250" data-height="201" src="https://cdn-images-1.medium.com/max/800/1*dhdPdG9jqmZMe8rlfBUfFQ.png"><figcaption class="imageCaption">RHEL for Edge boot pointer to a specific deployment example</figcaption></figure><p name="e3b9" id="e3b9" class="graf graf--p graf-after--figure">We are talking about performing that change “manually” or as a part of the upgrade process, but there are even implementations that automate the deployment rollback in case of errors such as <a href="https://github.com/fedora-iot/greenboot" data-href="https://github.com/fedora-iot/greenboot" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Greenboot</a> (available in RHEL for Edge and Fedora libostree variants), which permits to include scripts that check whatever thing that you find important, from any specifics from the system to the service provided by the application running on it and, if those tests fail as part of a system update, Greenboot will change back again the deployment and reboot to go back to safely automatically, with no external intervention.</p><p name="5451" id="5451" class="graf graf--p graf-after--p">One thing important to mention is that the decision about what filesystem snapshot (deployment) is used, as mentioned before, is done at boot time, so if you want to change to a new deployment you will need to reboot your system to make the changes effective.</p><p name="ece3" id="ece3" class="graf graf--p graf-after--p">This is different from the “regular” package-based Linux distributions where (sometimes) you can update your binaries without the need to restart your system, but this change-at-boot also assures consistency across all binaries and running processes, which is a great benefit of image-based systems. And remember, thanks to this consistency we get one of the coolest features of the libostree Operating Systems: system rollbacks</p><p name="c4ff" id="c4ff" class="graf graf--p graf-after--p">Think about that, we selected a “new filesystem version” to be booted on the next restart… but nothing prevents you to select a previous version instead since we are using consistent filesystem images/snapshots, it’s just a matter of where to target our symbolic link to.</p><p name="8b91" id="8b91" class="graf graf--p graf-after--p">All this means that you can track root filesystem versioning following the same methodology that you use with Git source repositories, make changes without affecting previous deployments, and switch between versions as easily as changing a simple symbolic link…This is a huge benefit!</p><p name="c631" id="c631" class="graf graf--p graf-after--p">But there is more. We talked about generating new “images” of the OS that will update the system. We could be thinking about generating the images on the same system that will be updated… but better think about centralizing this operation in an external place, which gives you several benefits.</p><p name="e085" id="e085" class="graf graf--p graf-after--p">Probably you don’t have just a single system that you will be maintained, you might have tens or even thousands of them (ie. Edge Computing use cases). In that case, you could generate the updates on a central site, publish them on an HTTP server (or send them over physical in a USB) and then make the systems either update automatically or just download the new deployment (OS “image”) and wait until the right moment to apply it.</p><figure name="939c" id="939c" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*iNjnfYfOw09plubDPFbelA.png" data-width="1479" data-height="450" src="https://cdn-images-1.medium.com/max/800/1*iNjnfYfOw09plubDPFbelA.png"><figcaption class="imageCaption">Example of image generation in a centralized place for Edge Computing use cases</figcaption></figure><p name="86a1" id="86a1" class="graf graf--p graf-after--figure">This approach simplifies a lot the management at scale but also permits to have the change tracking in a central place (when, what, who). And additionally, another benefit: when you install Software packages, you will be only calculating the dependencies, executing the %post scripts, performing the SELinux labeling and downloading the repositories the dependencies once in the central location, instead of having to waste the compete and network power one time per system, since you will be installing the packages at the image that you are creating in that centralized place and that will be shared with all the rest of systems.</p><p name="d8f4" id="d8f4" class="graf graf--p graf-after--p">And talking about Software packages, probably when I create a new OS image revision I will need to add or remove Software Packages, but I’m generating the new deployment with <em class="markup--em markup--p-em">libostree</em> now….</p><h3 name="42d6" id="42d6" class="graf graf--h3 graf-after--p">Does it mean that I don’t need any Package System?</h3><p name="68e7" id="68e7" class="graf graf--p graf-after--h3">You might be thinking…if libostree is the one who manages the updates of the system… I don’t need any package manager (APT, DNF, etc)…well, no, <em class="markup--em markup--p-em">libostree</em> is not a package manager and you probably want to install one in your system.</p><p name="0398" id="0398" class="graf graf--p graf-after--p">A package manager is a tool that simplifies the management of Software packages (install, remove, update or configure), which are archive files containing the pre-compiled binaries and configuration files that shape an actual Software application. These packages were created to remove the need of compiling Sofware from source code in order to install something in your system.</p><p name="9e01" id="9e01" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Libostree</em> only manages complete bootable file system trees, not individual files, actually, it has<strong class="markup--strong markup--p-strong"> </strong>no knowledge of individual files at all (how they were generated, their origin, …) so it needs a separate mechanism to install additional packaged applications. You still need a package manager if you want to keep the simplicity of packaged Software instead of coming back to compile from source code on your own like in the not-that-good-old-days.</p><p name="a763" id="a763" class="graf graf--p graf-after--p">But you cannot use package managers as they are, since they probably don’t expect to have your OS in a read-only filesystem. You need a “hybrid” package manager that knows how to deal with <em class="markup--em markup--p-em">libostree</em>.</p><p name="65b9" id="65b9" class="graf graf--p graf-after--p">In RHEL for Edge and Fedora systems, for example, you have the <a href="https://coreos.github.io/rpm-ostree/" data-href="https://coreos.github.io/rpm-ostree/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">rpm-ostree</em> hybrid package manager</a> which combines the <em class="markup--em markup--p-em">libostree</em> updates with RPMs packages, using the same <code class="markup--code markup--p-code">/etc/yum.repos</code> sources but including the RPMs as a layer on top of the <em class="markup--em markup--p-em">libostree</em> system.</p><p name="508d" id="508d" class="graf graf--p graf-after--p">How is that “combination” between <em class="markup--em markup--p-em">libostree</em> and <em class="markup--em markup--p-em">rpm </em>done? DNF installs the packages in the filesystem created by <em class="markup--em markup--p-em">libostree</em> (copied from the original deployment), and then a new image is created from that modified copy of the original filesystem containing the required rpm packages which will be the actual “new version of the <em class="markup--em markup--p-em">libostree</em> deployment” (in contrast with the intermediate image that was created at the beginning by libostree). It probably will be better understood by reviewing the steps of an update performed with <em class="markup--em markup--p-em">rpm-ostree</em>:</p><p name="484e" id="484e" class="graf graf--p graf-after--p">1. libostree checks out a copy of the filesystem as we saw previously</p><p name="b6ba" id="b6ba" class="graf graf--p graf-after--p">2. DNF installs packages into that new filesystem copy</p><p name="26b5" id="26b5" class="graf graf--p graf-after--p">3. libostree checks in the copy as a new object</p><p name="f323" id="f323" class="graf graf--p graf-after--p">4. libostree checks out the copy to become the new file system</p><p name="a842" id="a842" class="graf graf--p graf-after--p">5. Reboot to pick up the new system files</p><h3 name="c541" id="c541" class="graf graf--h3 graf-after--p">What about the configs and user data?</h3><p name="54a5" id="54a5" class="graf graf--p graf-after--h3">We have been talking about the need of mounting the root OS filesystem as read-only to prevent changes on the file hard-links out of the <em class="markup--em markup--p-em">libostree</em> control, but any OS will need write access to configuration files, or user data, so you cannot make all the OS directories read-only.</p><p name="2383" id="2383" class="graf graf--p graf-after--p">Actually, by default, <em class="markup--em markup--p-em">libostree</em> mount just <code class="markup--code markup--p-code">/usr</code> as read-only and include all the directory trees that should be not modified there (ie. libs, bins, etc) but to be honest, there is way more, as an example, I can tell you that in <code class="markup--code markup--p-code">/usr/etc</code> you can find all the <code class="markup--code markup--p-code">/etc</code> files that were changed giving you the chance to include cool features such as “return system to factory configuration”.</p><p name="0b36" id="0b36" class="graf graf--p graf-after--p">Regarding those directories that must have read/write permissions, there is something else to be considered. There is one differentiator between “writable” OS files that creates two sub-groups here. There are files that are attached/bound to a specific OS deployment while others will need to be “independent”.</p><p name="f4c0" id="f4c0" class="graf graf--p graf-after--p">For example, let’s suppose that in deployment “A” I have an application in version “1” which needs a configuration file that would need to be writable (so you can tune the config without having to create a new image). Now you update the application to version “2” so you create a new deployment “B”, but in the application release transition, developers changed the configuration file options (maybe including or removing parameters, or even changing the configuration file format), so the configuration files must be “dedicated” to their respective deployment in order to make possible that the application can find the expected configuration file for each release. In contrast, my applications won’t be affected by what kind of cat pictures I downloaded from Internet between the different OS deployments.</p><p name="adc9" id="adc9" class="graf graf--p graf-after--p">So in summary, there are cases where the writable files must be replicated along with the read-only file systems when a new deployment is created, and others that just are shared between them (they are not “copied / replicated / versioned” when new deployments are created). For writable files that need to be bound to specific deployments, by default, <em class="markup--em markup--p-em">libostree</em> uses <code class="markup--code markup--p-code">/etc</code> while for files that are independent and that will be shared it uses <code class="markup--code markup--p-code">/var</code>.</p><p name="3686" id="3686" class="graf graf--p graf-after--p">There is a special case that I didn’t touch on so far: User and Group management. Users and Groups are usually configured in <code class="markup--code markup--p-code">/etc/passwd</code> and <code class="markup--code markup--p-code">/etc/groups</code> files, so they would be part of the “writable files associated with a specific deployment” which could make sense for “system users” that execute OS processes, but the problem is that admins could also potentially create additional “regular” (dynamic) users. Why is that a problem? For example, when you deploy for the first time a <em class="markup--em markup--p-em">libostree</em> OS you will have a <code class="markup--code markup--p-code">/etc/passwd</code> (“v1”) file. Imagine that an admin using that first deployment creates a new user “<em class="markup--em markup--p-em">luis</em>”, which will imply to write in <code class="markup--code markup--p-code">/etc/passwd</code>so it will become “v2&quot;. Now imagine that at the same time, I want to include a new system user as part of the <em class="markup--em markup--p-em">libostree</em> update. The conflict arises because the <em class="markup--em markup--p-em">libostree</em> update process (I’m not talking about modifications made by RPMs) does not write over the <code class="markup--code markup--p-code">/etc/passwd</code> v2 including the new system user, it would do it in the <code class="markup--code markup--p-code">/etc/passwd</code> file “v1” because that’s the one that it finds in the chroot OS snapshot. What it will do in fact is to check the status of the <code class="markup--code markup--p-code">/etc</code> files, and then it will find that <code class="markup--code markup--p-code">/etc/passwd</code> has been modified from the “template” version (v1), so it will maintain that version (v2), making it impossible to include additional system users if someone modifies the <code class="markup--code markup--p-code">/etc/passwd</code> file (same for groups in <code class="markup--code markup--p-code">/etc/groups</code>). what could be done here?, <em class="markup--em markup--p-em">libostree</em> does not impose a solution for this corner case, but in Fedora/RHEL distros you find a possible solution: <a href="https://github.com/aperezdc/nss-altfiles" data-href="https://github.com/aperezdc/nss-altfiles" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">nss-altfiles</em></a> . This piece of Software permits to include of additional files describing users and groups besides <code class="markup--code markup--p-code">/etc/passwd</code> and <code class="markup--code markup--p-code">/etc/groups</code>, so the solution is to create a file that will be bound to the system users in the chroot read-only filesystem (<code class="markup--code markup--p-code">/usr/lib/passwd</code> and <code class="markup--code markup--p-code">/usr/lib/groups</code> ) and use <a href="https://github.com/aperezdc/nss-altfiles" data-href="https://github.com/aperezdc/nss-altfiles" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">nss-altfiles</em></a> to add that information to the ones described in <code class="markup--code markup--p-code">/etc/passwd</code> and <code class="markup--code markup--p-code">/etc/groups</code> which will hold the dynamic users created by admins.</p><p name="94ef" id="94ef" class="graf graf--p graf-after--p">Let’s forget about corner cases and go back to the simplicity of writable directories “bound” or “not bound” to a deployment.</p><p name="3bd4" id="3bd4" class="graf graf--p graf-after--p">Now that we know that <code class="markup--code markup--p-code">/etc</code> is used to host files that are bound to specific deployments, and in<code class="markup--code markup--p-code">/var</code> there are files that are independent, we can easily understand what happens with those directories when a new deployment is created by libostree: the <code class="markup--code markup--p-code">/etc</code> location is copied, so when it performs a <em class="markup--em markup--p-em">dnf</em> install (if you are using <em class="markup--em markup--p-em">rpm-ostree</em>), which could potentially change the config file format, it will modify the new copy associated with the new deployment, and let the old one untouched. At the same time, <code class="markup--code markup--p-code">/var</code> is just shared between them so the same files are accessible in both deployments.</p><figure name="b8d6" id="b8d6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*iowVb-fK_NEpWmiJVCImoQ.png" data-width="734" data-height="551" src="https://cdn-images-1.medium.com/max/800/1*iowVb-fK_NEpWmiJVCImoQ.png"><figcaption class="imageCaption">Directories transition between different libostree deployments</figcaption></figure><p name="1ace" id="1ace" class="graf graf--p graf-after--figure">Each libostree Operating System can decide what to put on <code class="markup--code markup--p-code">/var</code>, but it’s a good idea to include there the users&#39; home directory (traditionally <code class="markup--code markup--p-code">/home</code>) so they can write and keep their cat pictures downloaded from Internet. We can take a look at the directory distribution in RHEL for Edge as an example, and compare it with the non-<em class="markup--em markup--p-em">libostree</em> (“regular”) RHEL directory tree (check out the “new” tag for changes):</p><figure name="ea58" id="ea58" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Zu78tuQFW90rPPMkxrPcSg.png" data-width="650" data-height="521" src="https://cdn-images-1.medium.com/max/800/1*Zu78tuQFW90rPPMkxrPcSg.png"><figcaption class="imageCaption">RHEL for Edge directory tree</figcaption></figure><p name="6841" id="6841" class="graf graf--p graf-after--figure">We can see here how <code class="markup--code markup--p-code">/usr</code> is mounted as read-only and. In order to maintain the common Linux directory structure, several links were created to the new location (in <code class="markup--code markup--p-code">/usr</code>), I’m talking about directories such as <code class="markup--code markup--p-code">/lib</code> or <code class="markup--code markup--p-code">/sbin</code>. You can also check that <code class="markup--code markup--p-code">/etc</code> and <code class="markup--code markup--p-code">/var</code> have write access and how <code class="markup--code markup--p-code">/home</code> or <code class="markup--code markup--p-code">/root</code> are redirected to <code class="markup--code markup--p-code">/var</code> along with other directories that contain files that are “independent” from the OS deployment.</p><p name="2e4d" id="2e4d" class="graf graf--p graf-after--p">The rest of the directories are “special” locations that you can find in Linux distros, but you can also find a new <code class="markup--code markup--p-code">/sysroot</code> directory along with a new <code class="markup--code markup--p-code">/ostree</code> link. As we saw, our root directory tree is in fact a <em class="markup--em markup--p-em">chroot jail</em>, which means that your <code class="markup--code markup--p-code">/</code> “virtual” directory tree is in fact hosted “physically” somewhere else (along with other <code class="markup--code markup--p-code">/</code> from different deployments). That “real” place where the different chroot directories are holded is <code class="markup--code markup--p-code">/sysroot</code>, in fact, if you check the screen captures that I included above to demonstrate the different OS deployments using chroot, you will see that they are placed in <code class="markup--code markup--p-code">/sysroot/ostree</code>and that’s also why the <code class="markup--code markup--p-code">/sysroot</code> directory on each deployment chroot directory is empty (because it must “really exist” on the system, outside the <em class="markup--em markup--p-em">chroot jail</em>).</p><h3 name="e028" id="e028" class="graf graf--h3 graf-after--p">I should have included a TL/DR in this article…</h3><p name="f1b5" id="f1b5" class="graf graf--p graf-after--h3">…although if you have read all this “stuff” until this point, you probably don’t mind if I add a quick summary here.</p><p name="dcd1" id="dcd1" class="graf graf--p graf-after--p">We have seen how there was a need for a quick way to “fork” the Operating System (including data and Hardware device access), where you could rollback to the original version easily. They need that in order to develop and test Software that could break the system in a safe manner. After exploring multiple alternatives (virtualization, containers, etc) it was clear that a new way of managing the OS lifecycle needed to be created because the alternatives didn’t cover all the gaps.</p><p name="b905" id="b905" class="graf graf--p graf-after--p">One idea started taking form: What if we manage the Operating System following the same Git concept as if it were a source code repository where you can fork, roll back, track changes, etc… ?</p><p name="e345" id="e345" class="graf graf--p graf-after--p">Once the idea was clear it was only needed to choose the right Linux main technologies and features that would permit to implement the Git concept for the OS lifecycle management, and the answer was: c<em class="markup--em markup--p-em">hroot</em> and file hard-links:</p><ul class="postList"><li name="aa92" id="aa92" class="graf graf--li graf-after--p"><em class="markup--em markup--li-em">chroot</em> to isolate the different OS root filesystems (forks)</li><li name="e7b3" id="e7b3" class="graf graf--li graf-after--li">File hard-links to avoid file duplicates between the different OS root filesystems (limiting the impact of cross-changes due to linking with read-only filesystems)</li></ul><p name="50e3" id="50e3" class="graf graf--p graf-after--li">With those components as the foundation, a new approach to the OS update lifecycle was created, and the new technology was called <em class="markup--em markup--p-em">libostree</em>, also known as <em class="markup--em markup--p-em">OSTree</em>.</p><p name="df4e" id="df4e" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">Libostree</em> is a new system for versioning updates of Linux-based Operating Systems which brings several benefits:</p><ul class="postList"><li name="dc4b" id="dc4b" class="graf graf--li graf-after--p">You can perform transactional upgrades (which can be done incrementally over HTTP)</li><li name="1260" id="1260" class="graf graf--li graf-after--li">You can perform rollback for the Operating System (including auto-rollback if something is not working after the update)</li><li name="1a5c" id="1a5c" class="graf graf--li graf-after--li">You can centralize the image generation, which provides OS consistency across multiple systems and also reduces the amount of computing power and network bandwidth needed to install Software packages (with<em class="markup--em markup--li-em"> rpm-ostree</em>)</li><li name="f312" id="f312" class="graf graf--li graf-after--li">You can have prepared multiple OS deployments (parallel installs) where you can boot at anytime</li><li name="f92b" id="f92b" class="graf graf--li graf-after--li">You have a track of changes thanks to a versioning system inspired by Git source-code repositories</li></ul><h3 name="02b4" id="02b4" class="graf graf--h3 graf-after--li">But why a libostree OS could be interesting to me?</h3><p name="346b" id="346b" class="graf graf--p graf-after--h3">I know that you like to learn new things to expand your mind and wisdom, but let’s focus just for a moment on the practical side of the <em class="markup--em markup--p-em">libostree</em> / <em class="markup--em markup--p-em">OSTree</em> concept. We have seen the benefits but, how is it relevant for any business/technical use case?</p><p name="2995" id="2995" class="graf graf--p graf-after--p">The benefits that you get out of a libostree OS could be applied to multiple use cases, but let’s focus on two of them.</p><p name="4e0c" id="4e0c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Container-focused Operating System</strong></p><p name="8e90" id="8e90" class="graf graf--p graf-after--p">Maybe you have realized that the way that we perform updates and rollbacks in a <em class="markup--em markup--p-em">libostree</em>-based OS is similar to what you do with containers, where you can use different container images versions from the container image registry, selected based on labels, and that you update by performing “a restart”. But there is more, the architecture is also similar since both boots from read-only disk and keep user data on different volumes.</p><p name="1b38" id="1b38" class="graf graf--p graf-after--p">The lifecycle of both have similarities and the good side is that with <em class="markup--em markup--p-em">libostree</em>-based systems that are running “only” containers you could completely split the lifecycle of the applications (containers) from the lifecycle of the OS, but at the same time you can follow the same practices for both.</p><blockquote name="e234" id="e234" class="graf graf--blockquote graf-after--p">Note: As you can imagine, eventhough both tradicional and containerized workloads can be executed, containers are preferred since they have an independent life-cycle from the current Operating System image deployed.</blockquote><p name="d511" id="d511" class="graf graf--p graf-after--blockquote">For those reasons, you find <em class="markup--em markup--p-em">libostree</em> Operating Systems such as Fedora/<a href="https://docs.openshift.com/container-platform/4.11/architecture/architecture-rhcos.html" data-href="https://docs.openshift.com/container-platform/4.11/architecture/architecture-rhcos.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RHEL CoreOS</a>, which is used as the Operating System that hosts the <a href="https://www.redhat.com/en/technologies/cloud-computing/openshift/container-platform" data-href="https://www.redhat.com/en/technologies/cloud-computing/openshift/container-platform" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">OpenShift Container Platform</a>.</p><p name="cdc5" id="cdc5" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Edge computing</strong></p><p name="dee3" id="dee3" class="graf graf--p graf-after--p">This is another interesting use case. In a previous article relative to <a href="https://fidoalliance.org/intro-to-fido-device-onboard/" data-href="https://fidoalliance.org/intro-to-fido-device-onboard/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">FIDO device onboarding (FDO)</a> feature (link below), which is quite interesting for Edge Computing use cases and which is available on RHEL, I introduced some common aspects that you find in an Edge computing solution architecture.</p><div name="b689" id="b689" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://luis-javier-arizmendi-alonso.medium.com/edge-computing-device-onboarding-part-i-introducing-the-challenge-59add9a86200" data-href="https://luis-javier-arizmendi-alonso.medium.com/edge-computing-device-onboarding-part-i-introducing-the-challenge-59add9a86200" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://luis-javier-arizmendi-alonso.medium.com/edge-computing-device-onboarding-part-i-introducing-the-challenge-59add9a86200"><strong class="markup--strong markup--mixtapeEmbed-strong">Edge Computing device onboarding — Part I— Introducing the challenge</strong><br><em class="markup--em markup--mixtapeEmbed-em">This article outlines the challenges that you will face while performing a secure device onboarding at the scale…</em>luis-javier-arizmendi-alonso.medium.com</a><a href="https://luis-javier-arizmendi-alonso.medium.com/edge-computing-device-onboarding-part-i-introducing-the-challenge-59add9a86200" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="3f63f553f566685c998f5ae4bb8d1ab2" data-thumbnail-img-id="0*ppfmF_631ByMgkQl" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*ppfmF_631ByMgkQl);"></a></div><p name="9f41" id="9f41" class="graf graf--p graf-after--mixtapeEmbed">I will copy-paste that list here:</p><ul class="postList"><li name="f5f2" id="f5f2" class="graf graf--li graf-after--p">It will be capable of working in small HW footprint environments</li><li name="4f23" id="4f23" class="graf graf--li graf-after--li">It will work at big scale</li><li name="6300" id="6300" class="graf graf--li graf-after--li">It will tolerate network disruption (or being disconnected)</li><li name="3f5d" id="3f5d" class="graf graf--li graf-after--li">It will be fully automated with a central point of management and observability</li><li name="898b" id="898b" class="graf graf--li graf-after--li">I will secure data at rest and in transit (even against physical threats)</li><li name="b3a0" id="b3a0" class="graf graf--li graf-after--li">I will be able to be integrated with external IT and OT systems and protocols</li></ul><p name="1f8a" id="1f8a" class="graf graf--p graf-after--li">If you paid attention to the benefits stated about <em class="markup--em markup--p-em">libostree</em>, you probably can see how some of its features are the perfect match to cover the needs of Edge Computing architectures. Just as a quick example:</p><ul class="postList"><li name="2792" id="2792" class="graf graf--li graf-after--p">Updates are atomic and are done incrementally, only downloading the differences, so it provides better usage of the computing power and network bandwidth that are essential to reduce resource consumption at edge locations (not-good-enough networks, small HW footprint environments, …)</li><li name="af89" id="af89" class="graf graf--li graf-after--li">You also get less resource consumption (compute and network) while installing or updating Software packages, since as we saw, all the dependency calculations, %post scripts executing, SELabeling, and repository downloading are done once at the central site, opposite to having to perform the same task one time per system (which could be huge in Edge Computing environments) in locations where network and compute power capabilities are not the someones that you could find in a Data Center.</li><li name="5c92" id="5c92" class="graf graf--li graf-after--li">When you work at scale you would like to have a consistent platform where you don’t have different Software versions in different locations on systems that should perform the same task. You get this out-of-the-box thanks to the usage of OS images (<em class="markup--em markup--li-em">libostree</em> commits) that can be distributed both online or offline to the edge locations. And it is not just consistency, the usage of images also gives you better reproducibility.</li><li name="1211" id="1211" class="graf graf--li graf-after--li">Probably in the Edge Computing remote locations, there are no specialized people that could install or perform troubleshooting of the devices (more about this in the FDO article above), so having a system that you can update and, if something starts failing, you could rollback either manually or automatically is a great advantage</li><li name="bfab" id="bfab" class="graf graf--li graf-after--li">Although it is not something exclusively of Edge Computing environments, when you work at that scale is quite beneficial to get the change tracking capabilities that a Git-like system provides</li></ul><p name="0b40" id="0b40" class="graf graf--p graf-after--li">These are some of the points why the usage of <em class="markup--em markup--p-em">libostree</em> Operating Systems as the base systems on Edge Computing devices is a good idea, and for example, <a href="https://docs.ota.here.com/ota-client/latest/comparing-full-filesystem-update-strategies.html" data-href="https://docs.ota.here.com/ota-client/latest/comparing-full-filesystem-update-strategies.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">it is why some embedded systems manufacturers are moving away from old “dual-bank” architectures and providing <em class="markup--em markup--p-em">libostree</em> devices.</a></p><h3 name="35b2" id="35b2" class="graf graf--h3 graf-after--p">I’m convinced, how can I play with one libostree OS?</h3><p name="5cca" id="5cca" class="graf graf--p graf-after--h3">Good!, I will give you two options here.</p><blockquote name="4ac6" id="4ac6" class="graf graf--blockquote graf-after--p">Note: If you have OpenShift probably it is not a good idea to start playing with CoreOS since the whole management of the Operating System is performed by OpenShift</blockquote><p name="ab68" id="ab68" class="graf graf--p graf-after--blockquote">The first one is going to <a href="https://getfedora.org/" data-href="https://getfedora.org/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://getfedora.org/</a> and choosing any of the editions that I marked with a red square below.</p><figure name="161b" id="161b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*yRGSr5JNxnuefLobNOAKDw.png" data-width="1159" data-height="1539" src="https://cdn-images-1.medium.com/max/800/1*yRGSr5JNxnuefLobNOAKDw.png"><figcaption class="imageCaption">Fedora editions based on libostree</figcaption></figure><p name="8aab" id="8aab" class="graf graf--p graf-after--figure">For example, in my case, I’m running <a href="https://silverblue.fedoraproject.org/" data-href="https://silverblue.fedoraproject.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Fedora Silverblue</a> on my laptop, and to be honest, the rollback functionality was super-useful. I will share a personal experience. One time I updated my laptop during the afternoon while the next morning (9 am) I had an important meeting…. Imagine what, my NVIDIA drivers decided to prevent the OS start. I couldn’t imagine that because it was the first time that something was not working after an update in Fedora (I don’t have the same experience with other distros), but what I did then is rollback to my previous deployment (before updating and where my NVIDIA drivers were still working), deliver a successful presentation and after that, when I had time, I fixed the issue to make my system work again with the new update.</p><p name="a893" id="a893" class="graf graf--p graf-after--p">I suggest trying Fedora Silverblue as the first step since Fedora IoT is kind of special since you need to perform additional steps to get your image ready to be used.. this can make it your second libostree distro to be tested.</p><p name="a2b0" id="a2b0" class="graf graf--p graf-after--p">But if you want to go with an option more “Enterprise ready” I would suggest checking <a href="https://www.redhat.com/en/resources/meet-workload-demands-edge-computing-datasheet" data-href="https://www.redhat.com/en/resources/meet-workload-demands-edge-computing-datasheet" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RHEL for Edge</a> which actually is similar to Fedora IoT but where you own the Image building process too, so you can also learn about it.</p><p name="c397" id="c397" class="graf graf--p graf-after--p">You could start from the <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/composing_installing_and_managing_rhel_for_edge_images/introducing-rhel-for-edge-images_composing-installing-managing-rhel-for-edge-images" data-href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/composing_installing_and_managing_rhel_for_edge_images/introducing-rhel-for-edge-images_composing-installing-managing-rhel-for-edge-images" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">official docs</a> but if you want a quick ramp-up you could use the “quick-start” scripts that I created (link below) to simplify the RHEL for Edge image creation.</p><div name="a615" id="a615" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/luisarizmendi/rhel-edge-quickstart" data-href="https://github.com/luisarizmendi/rhel-edge-quickstart" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/luisarizmendi/rhel-edge-quickstart"><strong class="markup--strong markup--mixtapeEmbed-strong">GitHub - luisarizmendi/rhel-edge-quickstart</strong><br><em class="markup--em markup--mixtapeEmbed-em">These scripts help to quickly create and publish RHEL for Edge images. You should execute them in a RHEL 9 server which…</em>github.com</a><a href="https://github.com/luisarizmendi/rhel-edge-quickstart" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="1ef4fd4ecc16a1ebd4bcadfd953d6be2" data-thumbnail-img-id="0*fPHGiVSIcqpjYefZ" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*fPHGiVSIcqpjYefZ);"></a></div><p name="cc38" id="cc38" class="graf graf--p graf-after--mixtapeEmbed">That’s all!</p><p name="9601" id="9601" class="graf graf--p graf-after--p">I hope that you enjoyed reading this long article and that you cannot wait to start exploring the libostree OS benefits on your own.</p><p name="ff37" id="ff37" class="graf graf--p graf-after--p graf--trailing">Thanks for reading.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@luis-javier-arizmendi-alonso" class="p-author h-card">Luis Javier Arizmendi Alonso</a> on <a href="https://medium.com/p/d84211e97933"><time class="dt-published" datetime="2022-08-25T14:16:21.410Z">August 25, 2022</time></a>.</p><p><a href="https://medium.com/@luis-javier-arizmendi-alonso/a-git-like-linux-operating-system-d84211e97933" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on November 30, 2022.</p></footer></article></body></html>
<nav class="pagination">
  <span class="prev"><a href="01-fdo-lab.html">1.B FIDO Device Onboarding (FDO) - Lab</a></span>
  <span class="next"><a href="02-rfe-lab.html">2.B RHEL OSTree images - Lab</a></span>
</nav>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <a class="rhd-logo" href="https://developers.redhat.com" target="_blank"></div>
</footer>
<script src="../_/js/vendor/clipboard.js"></script>
<script src="../_/js/site.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>
  </body>
</html>
