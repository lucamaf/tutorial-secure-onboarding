<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RHEL OSTree images - Intro :: Secure Edge device onboarding with RHEL and FDO</title>
    <link rel="canonical" href="https://luisarizmendi.github.io/tutorial-secure-onboarding/fdo-tutorial/02-rfe-intro.html">
    <link rel="prev" href="01-fdo-lab.html">
    <link rel="next" href="02-rfe-lab.html">
    <meta name="generator" content="Antora 3.0.0">
    <link rel="stylesheet" href="../_/css/site.css">
<link rel="icon" href="../_/img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com/en/technologies/device-edge" target="_blank"><img
          src="../_/img/header_logo.png" height="50px" alt="Red Hat Device Edge"></a>
      <a class="navbar-link" style="color:white;font-weight: bold;font-size: 1.5rem" href="https://luisarizmendi.github.io/tutorial-secure-onboarding">Secure Edge device onboarding with RHEL and FDO</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Repos</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://github.com/luisarizmendi/rhel-edge-quickstart" target="_blank">RHEL OSTree quickstart scripts</a>
          </div>
        </div>
       
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Articles</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://medium.com/@luis-javier-arizmendi-alonso/edge-computing-device-onboarding-part-i-introducing-the-challenge-59add9a86200" target="_blank">FDO series</a>
            <a class="navbar-item" href="https://medium.com/@luis-javier-arizmendi-alonso/a-git-like-linux-operating-system-d84211e97933" target="_blank">RHEL OSTree</a>


          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Slides</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://docs.google.com/presentation/d/1FKQDHrleCPuE0e36UekzXdkw86wNDx16dSgllXj-swY/edit?usp=sharing" target="_blank">Red Hat Device Edge (internal)</a>

          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">More Tutorials</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://redhat-scholars.github.io/openshift-starter-guides/rhs-openshift-starter-guides/4.9/index.html" target="_blank">OpenShift</a>
            <a class="navbar-item" href="https://redhat-scholars.github.io/kubernetes-tutorial/" target="_blank">Kubernetes</a>
            <a class="navbar-item" href="https://redhat-scholars.github.io/istio-tutorial/" target="_blank">Istio</a>
            <a class="navbar-item" href="https://redhat-developer-demos.github.io/quarkus-tutorial/" target="_blank">Quarkus</a>
            <a class="navbar-item" href="https://redhat-developer-demos.github.io/knative-tutorial/" target="_blank">Knative</a>
            <a class="navbar-item" href="https://redhat-scholars.github.io/tekton-tutorial/" target="_blank">Tekton</a>
            <a class="navbar-item" href="https://redhat-scholars.github.io/acs-workshop/acs-workshop/index.html" target="_blank">ACM</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header><div class="body">
<div class="nav-container" data-component="fdo-tutorial" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html" class=" query-params-link">Secure Edge device onboarding with RHEL and FDO</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00-prerequisites.html">Lab prerequisites</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-prerequisites.html#virtualization">Prepare your virtualization environment</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-prerequisites.html#arch">Choose your lab architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-prerequisites.html#usecase">Create your use case</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00-intro.html">Introduction to secure edge device onboarding</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-intro.html#intro-scaling">Scaling traditional device deployment for the edge environments</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-intro.html#intro-security">Device onboarding security and image templates</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="00-intro.html#intro-fdo">Centralizing the device onboarding intelligence</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-intro.html">1.a FDO - Intro</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="01-fdo-intro.html#fdo-intro-origins">FDO&#8217;s origins</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="01-fdo-intro.html#fdo-intro-components">FDO components</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-intro.html#fdo-intro-workflow">FDO workflow</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-intro.html#fdo-intro-workflow-before">1. Before the first boot</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-intro.html#fdo-intro-workflow-during">2. During the first boot</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-intro.html#fdo-intro-workflow-after">3. After the first boot</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html">1.b FDO - Lab</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html#fdo-services">FDO services</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-lab.html#fdo-services-aio">Option 1: All-in-one FDO server installation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-lab.html#fdo-services-dedicated">Option 2: Dedicated FDO servers</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html#fdo-config">FDO Service API config</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona">Option A: Creating your own use case</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-user">initial_user</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-files">files</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-commands">commands</a>
  </li>
  <li class="nav-item" data-depth="4">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optiona-encrypt">diskencryption_clevis</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01-fdo-lab.html#fdo-optionb">Option B: Using the example use case</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="01-fdo-lab.html#fdo-summary">FDO Lab summary</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="02-rfe-intro.html">2.a RHEL OSTree images - Intro</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#rfe-intro-benefits">OSTree RHEL benefits for edge computing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#rfe-intro-article">OSTree-based Operating Systems article</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="02-rfe-lab.html">2.b RHEL OSTree image - Lab</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-rfe-lab.html#rfe-imagebuilder">Install Image builder</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="02-rfe-lab.html#rfe-image">Create the RHEL OSTree image</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02-rfe-lab.html#rfe-ostreeimage">Generating the repo image</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02-rfe-lab.html#rfe-ostreeimage-optiona">Option A: Blueprint file for your own FDO onboarding automation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02-rfe-lab.html#rfe-ostreeimage-optionb">Option B: Blueprint file for the provided FDO automation example</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02-rfe-lab.html#rfe-ostreeimage-createrepo">Creating the OSTree repository</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02-rfe-lab.html#rfe-publish">Publishing the repo image</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-rfe-lab.html#rfe-iso">Create the RHEL ISO</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="02-rfe-lab.html#rfe-summary">RHEL OSTree image Lab summary</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03-onboarding.html">3. Edge device onboarding - Lab</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-vm">Step 0 - Create the edge device VM</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-first">Step 1 - Edge device&#8217;s first boot</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-voucher">Step 2 - Distribute the Vouchers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-finalboot">Step 3 - Automatic onboarding</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-checks">Checking the edge device onboard</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-change">Updating the onboard automation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03-onboarding.html#onboard-summary">Edge device onboarding Lab summary</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="99-summary.html">Summary</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Secure Edge device onboarding with RHEL and FDO</span>
    <span class="version">master</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Secure Edge device onboarding with RHEL and FDO</span>
      <ul class="versions">
        <li class="version is-current">
          <a href="index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Secure Edge device onboarding with RHEL and FDO</a></li>
    <li><a href="02-rfe-intro.html">2.a RHEL OSTree images - Intro</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/luisarizmendi/tutorial-secure-onboarding/edit/master/documentation/modules/ROOT/pages/02-rfe-intro.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">RHEL OSTree images - Intro</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>A RHEL for Edge image is an rpm-ostree image that includes system packages to remotely install RHEL on Edge servers.</p>
</div>
<div class="paragraph">
<p>The system packages include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Base OS package</p>
</li>
<li>
<p>Podman as the container engine</p>
</li>
<li>
<p>Additional RPM content</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can customize the image to configure the OS content as per your requirements by using either Image Builder installed on an RHEL system or using <a href="http://console.redhat.com">Red Hat Hybrid Console</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rfe-intro-benefits"><a class="anchor" href="#rfe-intro-benefits"></a>OSTree RHEL benefits for edge computing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Working with an OSTree based Operating System has multiple benefits when they are applied to edge computing use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Simplified management</strong>: Secure and scale with the benefits of zero-touch provisioning, fleet health visibility, and quick security remediations throughout the whole lifecycle</p>
</li>
<li>
<p><strong>Platform consistency</strong>: Easily create purpose-built OS images optimized for the architectural challenges inherent at edge. It makes the system more  reliable and predictable.</p>
</li>
<li>
<p><strong>Efficient over-the-air updates</strong>: Updates transfer significantly fewer data and are ideal for remote sites with limited or intermittent connectivity</p>
</li>
<li>
<p><strong>Unattended resilience</strong>: Application specific health checks detect conflicts and automatically rollback an OS update, preventing downtime</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to know more about OSTree RHEL you can read the article attached below originally <a href="https://luis-javier-arizmendi-alonso.medium.com/a-git-like-linux-operating-system-d84211e97933">published in Medium</a>, otherwise jump directly into the <a href="02-rfe-lab.html" class="xref page">RHEL OSTree images Lab</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rfe-intro-article"><a class="anchor" href="#rfe-intro-article"></a>OSTree-based Operating Systems article</h2>
<div class="sectionbody">
<hr>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_a_git_like_linux_operating_system"><a class="anchor" href="#_a_git_like_linux_operating_system"></a>A “Git-like” Linux Operating System</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Probably you are getting their benefits but you don’t even know that you were using them, I’m talking about libostree Operating Systems.</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_a_git_like_linux_operating_system_2"><a class="anchor" href="#_a_git_like_linux_operating_system_2"></a>A “Git-like” Linux Operating System</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Probably you are getting their benefits but you don’t even know that you were using them*, I’m talking about libostree Operating Systems.</em></p>
</div>
<div class="paragraph">
<p><em>This is the history of how the needs of a group of developers made it possible, using standard Linux features and concepts borrowed from technologies such as Git, to manage a Linux OS lifecycle as if it were a source code repository.</em></p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>*If you are using OpenShift, Fedora IoT or <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/composing_installing_and_managing_rhel_for_edge_images/introducing-rhel-for-edge-images_composing-installing-managing-rhel-for-edge-images">RHEL for Edge</a>, you are using a libostree Linux Operating System, just as an example.</p>
</div>
</blockquote>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/0*1rmEc4TRAcHFe_gQ" alt="Image from https://unsplash.com/@eprouzet[Eric Prouzet] (unsplash.com)">
</div>
</div>
<div class="paragraph">
<p>Linux is great.</p>
</div>
<div class="paragraph">
<p>Linux is great…but let’s be clear, sometimes its flexibility gives more than one headache when it comes to Operating System lifecycle management.</p>
</div>
<div class="paragraph">
<p>We tried to overcome the challenges that we find while deploying, patching, upgrading, onboarding, decomissing, observing, recovering, and debugging Linux Operating Systems by using a specific set of tools that get the most from the OS features at the same time that simplifies and amplifies the management operations for our preferred Linux distribution.</p>
</div>
<div class="paragraph">
<p>We have tools that standardize the version of the binaries and software installed across multiple systems, tools that patch the OS if a new vulnerability is found, and tools that recover a previous state if something really wrong happens with your Linux, … but what if I tell you that there is an approach to solve these and other lifecycle management challenges? What if I just could manage the different OS lifecycle updates as if they were rooms in your own hotel, where I could sleep in a new one with a different view, bed, or decoration, but where if it does not convince me I could always go back to my preferred one where I feel comfortable and safe?</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Note: This is a long article, so I will be nice and I will tell you a secret, at the end of it I’ve included a summary that tries to cover the topic at high-level and outline the benefits of this kind of systems.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_do_we_need_something_different"><a class="anchor" href="#_why_do_we_need_something_different"></a>Why do we need “something” different?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When it comes to technology, sometimes “<em>less is more</em>”. If your smartphone provides a GPS map APP you probably won’t buy a physical GPS navigator. If your Linux can provide effective and easy-to-use out-of-box features, why would you need to configure and maintain any additional tools?</p>
</div>
<div class="paragraph">
<p>Think about the complexity (and cost) of the solutions out there that are promising Operating System rollbacks, incremental updates, OS consistency, or binary change history tracking. Wouldn’t be nice if I could accomplish that with just OS features? Of course, this statement can only be true if the out-of-the-box feature is, at least, as good as the ones provided by additional tooling, but we will see in this article how this new lifecycle management approach can provide these features and more.</p>
</div>
<div class="paragraph">
<p>You will also see how this “something” different, let’s call it <em>libostree</em> (name <em>OSTree</em> is also used), that started to provide a way to perform a more effective development, brings benefits that are the perfect match to cover the gaps that we find in many other fields, from Edge Computing to Hybrid-cloud use cases.</p>
</div>
<div class="paragraph">
<p>After that, we will see how common problems of several solution use cases will greatly benefit from the usage of libostree Linux.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_being_in_jail_is_not_always_a_badthing"><a class="anchor" href="#_being_in_jail_is_not_always_a_badthing"></a>Being in “Jail” is not always a bad thing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some years ago, some people were struggling with the complexity of developing using core aspects of the OS without “breaking things”, or at least having a safe way to “break things”. They ended up writing down a set of capabilities that they would like to have implemented to simplify the development (of GNOME) by being able to quickly create a new “instance” of the OS in the same system where they will perform some changes that could be easily reverted… but that will also cover several additional needs, such as sharing data between these multiple “versions” of the OS, using the system installed apps, specific hardware usage, etc…</p>
</div>
<div class="paragraph">
<p>Getting a new “OS instance” could be accomplished using technologies such as virtualization, containers, etc… but the creation process is slow (ie. create a new VM or building a new container takes some time) and access to the same system data, applications and Hardware is not always easy, along with that the kind of rollback capability that they were looking for was not trivial sometimes. They needed something else.</p>
</div>
<div class="paragraph">
<p>Based on those core requirements, and after reviewing some alternatives (virtualization, containers, BTRFS,…) they decided that “<em>chroot”</em> could be a good candidate as the foundation of something new that could help with the gaps they found.</p>
</div>
<div class="paragraph">
<p>“C<em>hroot”</em> is an operation that was introduced in the early days of Unix that changes the apparent directory used as “root directory” by the system, making it possible to create a “<em>jail</em>” environment for the applications running on it. It is used to create sandboxes for processes, so they cannot maliciously change data outside the chrooted directory, or as a lightweight substitute for VMs (remember they needed to “<em>quickly create a new OS instance</em>”, so it seems to be a good choice).</p>
</div>
<div class="paragraph">
<p>It could also sound familiar to “containers”, isn’t it? While the concept is similar, with the container “namespaces” you get additional isolation, which will prevent you to access certain OS resources that you would like to keep sharing… something that you can get when using “chroot jailed environments”.</p>
</div>
<div class="paragraph">
<p>Their idea was to make it possible to boot from different chroot directories, so they could potentially develop new features on one jail environment, being able to access some shared data along with other applications and, if they break something, just go back to the “original” chroot jail that wouldn’t be affected by their changes.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*E5x-H71-MDNgxzNDsWuZFA.png" alt="RHEL for Edge chroot directories example">
</div>
</div>
<div class="paragraph">
<p>But just using <em>chroot</em> was not enough because in order to provide these capabilities you need to make it work with other different bootloader components like GRUB, kernel init files, FS mount, etc… and not just only that, you need to take into account how to perform certain operations such as platform updates… and that’s what <strong><em>libostree</em></strong> is all about.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_git_like_versioning_model_for_bootable_filesystem"><a class="anchor" href="#_a_git_like_versioning_model_for_bootable_filesystem"></a>A “Git-like versioning model” for bootable filesystem</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you want to read a formal description of what libostree is you can check how it is described in its own <a href="https://github.com/ostreedev/ostree">source code repository:</a></p>
</div>
<div class="paragraph">
<p><a href="https://ostreedev.github.io/ostree/"><strong>libostree</strong><br>
<em>This project is now known as “libostree”, though it is still appropriate to use the previous name: “OSTree” (or…</em>ostreedev.github.io</a>https://ostreedev.github.io/ostree/[]</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Libostree is both a shared library and suite of command line tools that combines a “git-like” model for committing and downloading bootable filesystem trees, along with a layer for deploying them and managing the bootloader configuration.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>In other words, <em>libostree</em> is the missing piece that you need to have and maintain the lifecycle of a complete bootable Operating System based in multiple chroot jail environments… but wait, probably something got your attention, it says that <em>libostree</em> follows a “git-like model”. Why is there that reference?</p>
</div>
<div class="paragraph">
<p>Let’s step a little bit back. We have been talking about using <em>chroot</em> to create different “versions” of the root filesystem that could be booted. Those versions will probably have a lot of files that are identical to each other. Coping the same files into each “<em>chroot jail</em>” would consume a lot of space, then there must be another way to have the same files in different root folders but with neither replicating nor sharing them at the same time that you keep track of the version changes.</p>
</div>
<div class="paragraph">
<p>You might not be an expert in Git, but you probably know a little bit about storage technologies such as Object-based storage concepts and how unstructured data that is stored in a flat data environment can be described by using hash strings, like a key-value data store that binds the hash with the file metadata and finally with the actual data bits. Git works in a similar way.</p>
</div>
<div class="paragraph">
<p>Git is a database of objects identified by hash that are stored using a key-value data store concept. It has 4 different types of objects which identify the content of a file (<em>blob</em>), the directory structure (<em>tree</em>), the “versioning” info (<em>commit</em>), and annotations (<em>tag</em>).</p>
</div>
<div class="paragraph">
<p>While “<em>blobs</em>” and “<em>trees</em>” are enough to represent a complete file system, the “<em>commits</em>” contain the reference to the “<em>tree</em>” object describing the root directory of the repository, which provides a full versioning system. Two different versions could point to the same “<em>blob</em>” if the bits between versions didn’t change, which results in not having to replicate the bits between them.</p>
</div>
<div class="paragraph">
<p>Git seems the perfect match for what we are looking for, why not use it instead of creating a new git-like “thing” (<em>libostree</em>)?</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Note: If you want to check out the libostree objects you can find them here: <a href="https://ostreedev.github.io/ostree/repo/" class="bare">https://ostreedev.github.io/ostree/repo/</a></p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>I’ve already shared one reason, we need additional specific features to make the versioned filesystem become an actual versioned Linux bootable system (GRUB, init files, etc), but there is something more. Git was designed as a source code repository versioning system, which means that its features are focused on “text files”, in contrast, what we will need is mostly versioning of a mix of “text files” and “binary files” so the features must be optimized for both, not just text. For that reason, <em>libostree</em> is not just Git, it uses Git concepts and applies them in a very similar way, but the implementation is not exactly the same one.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_file_replicas_without_multiplying_the_spaceneeds"><a class="anchor" href="#_file_replicas_without_multiplying_the_spaceneeds"></a>File “replicas” without multiplying the space needs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we understood that <em>chroot</em> is the right technology to create the “jailed” root filesystem environments and that we would like to have a versioning system similar to what we get with Git, we need the Linux functionality that glues them together, and that is the file “hard linking”.</p>
</div>
<div class="paragraph">
<p>In Linux, we have <a href="https://www.redhat.com/sysadmin/linking-linux-explained">two kinds of file links: soft and hard links</a>. While soft links (symbolic links) are a special kind of file that points to another regular file (which points to the data), hard links are different filenames pointing directly to the same data and attributes (inode).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*C9W87v7Fg7XPg3xcFCWmJg.png" alt="RHEL for Edge /bin/bash hard links to the same inode since there were not changed between deployments">
</div>
</div>
<div class="paragraph">
<p>The two different types of links exist because they offer different capabilities. There is a key difference between them that makes hard links better suited for our git-like versioning use case. With hard links, if you delete the “target” file you can still have access to the data, while with soft links if you delete the target file the symbolic link will stop working and become useless. We need to have multiple “file replicas” on the same disk partition, and those replicas must be independent, so when you delete one file you wouldn’t like to “auto-delete” the rest of the “replicas”…</p>
</div>
<div class="paragraph">
<p>So it’s clear that soft-links are not an option and hard links are the way to go… but there is something else to bear in mind when using hard links…</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_you_wont_break_it_if_you_cannot_touchit"><a class="anchor" href="#_you_wont_break_it_if_you_cannot_touchit"></a>You won’t break it if you cannot touch it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have seen how Hard links provide the benefits that we saw, but its usage also has a big implication that we need to address: if you change the content in one hard-link file and so all the remaining file hard links pointing to the same inode will be changed too.</p>
</div>
<div class="paragraph">
<p>Why is that an issue? Imagine that you have two OS “snapshots” (let’s start calling them “deployments”) in your system: deployment A, and deployment B which are identical. While running on version B you change a binary version, but after that change, you realize that something is going wrong and you revert to version A…. the problem is that the same change that you did in deployment B, and which broke the system, is applied to your deployment A too so you won’t get rid of the issue that you created.</p>
</div>
<div class="paragraph">
<p>What’s the best solution to solve this problem? Well, actually it’s pretty simple: by default, do not allow to change anything.</p>
</div>
<div class="paragraph">
<p>Instead of allowing file changes like in a regular Operating System, making it necessary to build a complex change tracking system to be sure that any operation that changes a file is recorded to be processed afterward so you can revert it, you could just prevent changes by default and build a way to perform changes only under the control of your versioning system… and <em>libostree</em> was designed around this concept.</p>
</div>
<div class="paragraph">
<p>In order to prevent the changes, the Operating System is built on top of a read-only filesystem, so it works like an “image snapshot” of the root filesystem of the operating system, but of course, <em>libostree</em> need also to provide a method to perform effective changes to those images.</p>
</div>
<div class="paragraph">
<p>When you need to perform one (or a set of) changes, a new replica of the whole root filesystem is created (remember that that does not mean to double disk space needed and that creating that replica is quite fast) and the changes will take place on it. The files that you didn’t touch will remain as hard links, while the modified versions will become a new “regular” file or be deleted as in the example below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*FkV4F_EiM-0FvYnAzCzjkg.png" alt="RHEL for Edge example where zsh was removed in one deployment">
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Note: deployments can also be deleted to save some disk space, for example in this case if you won’t need zsh anymore you could remove the deployment that contains the binary (but remember that it will only free the size of that binary if that was the only change between deployments, the rest are just hard links)</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_read_only_does_not_mean_do_not_update_atall"><a class="anchor" href="#_read_only_does_not_mean_do_not_update_atall"></a>Read-only does not mean do-not-update at all</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let’s say that you have several application binaries that you would like to update, as we have seen, you need to create a new replica of your chroot filesystem with the new versions of the binaries but, how do I use that new replica?</p>
</div>
<div class="paragraph">
<p>When you are running in a deployment (remember deployment=filesystem version/revision) and create a new chroot directory with the changes, you are still running on the source version, you don’t instantaneity move to the new deployment… you just made a bunch of new hard links…. How do you make effective these changes to the “running OS”?</p>
</div>
<div class="paragraph">
<p>With <em>libostree</em>, at system boot time, one of the available OS root “snapshots/images/deployments” will be selected by following a symbolic link located in a specific place on the filesystem, so if you want to use any alternative root filesystem image (for example, the one with our new binaries) we just need to change the default (0) symbolic link and start pointing to this new filesystem “release”.</p>
</div>
<div class="paragraph">
<p>How is that included during the boot process? There is a new kernel argument in the <em>initramfs</em> file specifying the soft-link (which points to the deployment chroot filesystem).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*dhdPdG9jqmZMe8rlfBUfFQ.png" alt="RHEL for Edge boot pointer to a specific deployment example">
</div>
</div>
<div class="paragraph">
<p>We are talking about performing that change “manually” or as a part of the upgrade process, but there are even implementations that automate the deployment rollback in case of errors such as <a href="https://github.com/fedora-iot/greenboot">Greenboot</a> (available in RHEL for Edge and Fedora libostree variants), which permits to include scripts that check whatever thing that you find important, from any specifics from the system to the service provided by the application running on it and, if those tests fail as part of a system update, Greenboot will change back again the deployment and reboot to go back to safely automatically, with no external intervention.</p>
</div>
<div class="paragraph">
<p>One thing important to mention is that the decision about what filesystem snapshot (deployment) is used, as mentioned before, is done at boot time, so if you want to change to a new deployment you will need to reboot your system to make the changes effective.</p>
</div>
<div class="paragraph">
<p>This is different from the “regular” package-based Linux distributions where (sometimes) you can update your binaries without the need to restart your system, but this change-at-boot also assures consistency across all binaries and running processes, which is a great benefit of image-based systems. And remember, thanks to this consistency we get one of the coolest features of the libostree Operating Systems: system rollbacks</p>
</div>
<div class="paragraph">
<p>Think about that, we selected a “new filesystem version” to be booted on the next restart… but nothing prevents you to select a previous version instead since we are using consistent filesystem images/snapshots, it’s just a matter of where to target our symbolic link to.</p>
</div>
<div class="paragraph">
<p>All this means that you can track root filesystem versioning following the same methodology that you use with Git source repositories, make changes without affecting previous deployments, and switch between versions as easily as changing a simple symbolic link…This is a huge benefit!</p>
</div>
<div class="paragraph">
<p>But there is more. We talked about generating new “images” of the OS that will update the system. We could be thinking about generating the images on the same system that will be updated… but better think about centralizing this operation in an external place, which gives you several benefits.</p>
</div>
<div class="paragraph">
<p>Probably you don’t have just a single system that you will be maintained, you might have tens or even thousands of them (ie. Edge Computing use cases). In that case, you could generate the updates on a central site, publish them on an HTTP server (or send them over physical in a USB) and then make the systems either update automatically or just download the new deployment (OS “image”) and wait until the right moment to apply it.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*iNjnfYfOw09plubDPFbelA.png" alt="Example of image generation in a centralized place for Edge Computing use cases">
</div>
</div>
<div class="paragraph">
<p>This approach simplifies a lot the management at scale but also permits to have the change tracking in a central place (when, what, who). And additionally, another benefit: when you install Software packages, you will be only calculating the dependencies, executing the %post scripts, performing the SELinux labeling and downloading the repositories the dependencies once in the central location, instead of having to waste the compete and network power one time per system, since you will be installing the packages at the image that you are creating in that centralized place and that will be shared with all the rest of systems.</p>
</div>
<div class="paragraph">
<p>And talking about Software packages, probably when I create a new OS image revision I will need to add or remove Software Packages, but I’m generating the new deployment with <em>libostree</em> now….</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_does_it_mean_that_i_dont_need_any_packagesystem"><a class="anchor" href="#_does_it_mean_that_i_dont_need_any_packagesystem"></a>Does it mean that I don’t need any Package System?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You might be thinking…if libostree is the one who manages the updates of the system… I don’t need any package manager (APT, DNF, etc)…well, no, <em>libostree</em> is not a package manager and you probably want to install one in your system.</p>
</div>
<div class="paragraph">
<p>A package manager is a tool that simplifies the management of Software packages (install, remove, update or configure), which are archive files containing the pre-compiled binaries and configuration files that shape an actual Software application. These packages were created to remove the need of compiling Sofware from source code in order to install something in your system.</p>
</div>
<div class="paragraph">
<p><em>Libostree</em> only manages complete bootable file system trees, not individual files, actually, it has ** no knowledge of individual files at all (how they were generated, their origin, …) so it needs a separate mechanism to install additional packaged applications. You still need a package manager if you want to keep the simplicity of packaged Software instead of coming back to compile from source code on your own like in the not-that-good-old-days.</p>
</div>
<div class="paragraph">
<p>But you cannot use package managers as they are, since they probably don’t expect to have your OS in a read-only filesystem. You need a “hybrid” package manager that knows how to deal with <em>libostree</em>.</p>
</div>
<div class="paragraph">
<p>In RHEL for Edge and Fedora systems, for example, you have the <a href="https://coreos.github.io/rpm-ostree/"><em>rpm-ostree</em> hybrid package manager</a> which combines the <em>libostree</em> updates with RPMs packages, using the same <code>/etc/yum.repos</code> sources but including the RPMs as a layer on top of the <em>libostree</em> system.</p>
</div>
<div class="paragraph">
<p>How is that “combination” between <em>libostree</em> and <em>rpm</em> done? DNF installs the packages in the filesystem created by <em>libostree</em> (copied from the original deployment), and then a new image is created from that modified copy of the original filesystem containing the required rpm packages which will be the actual “new version of the <em>libostree</em> deployment” (in contrast with the intermediate image that was created at the beginning by libostree). It probably will be better understood by reviewing the steps of an update performed with <em>rpm-ostree</em>:</p>
</div>
<div class="paragraph">
<p>1. libostree checks out a copy of the filesystem as we saw previously</p>
</div>
<div class="paragraph">
<p>2. DNF installs packages into that new filesystem copy</p>
</div>
<div class="paragraph">
<p>3. libostree checks in the copy as a new object</p>
</div>
<div class="paragraph">
<p>4. libostree checks out the copy to become the new file system</p>
</div>
<div class="paragraph">
<p>5. Reboot to pick up the new system files</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_about_the_configs_and_userdata"><a class="anchor" href="#_what_about_the_configs_and_userdata"></a>What about the configs and user data?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have been talking about the need of mounting the root OS filesystem as read-only to prevent changes on the file hard-links out of the <em>libostree</em> control, but any OS will need write access to configuration files, or user data, so you cannot make all the OS directories read-only.</p>
</div>
<div class="paragraph">
<p>Actually, by default, <em>libostree</em> mount just <code>/usr</code> as read-only and include all the directory trees that should be not modified there (ie. libs, bins, etc) but to be honest, there is way more, as an example, I can tell you that in <code>/usr/etc</code> you can find all the <code>/etc</code> files that were changed giving you the chance to include cool features such as “return system to factory configuration”.</p>
</div>
<div class="paragraph">
<p>Regarding those directories that must have read/write permissions, there is something else to be considered. There is one differentiator between “writable” OS files that creates two sub-groups here. There are files that are attached/bound to a specific OS deployment while others will need to be “independent”.</p>
</div>
<div class="paragraph">
<p>For example, let’s suppose that in deployment “A” I have an application in version “1” which needs a configuration file that would need to be writable (so you can tune the config without having to create a new image). Now you update the application to version “2” so you create a new deployment “B”, but in the application release transition, developers changed the configuration file options (maybe including or removing parameters, or even changing the configuration file format), so the configuration files must be “dedicated” to their respective deployment in order to make possible that the application can find the expected configuration file for each release. In contrast, my applications won’t be affected by what kind of cat pictures I downloaded from Internet between the different OS deployments.</p>
</div>
<div class="paragraph">
<p>So in summary, there are cases where the writable files must be replicated along with the read-only file systems when a new deployment is created, and others that just are shared between them (they are not “copied / replicated / versioned” when new deployments are created). For writable files that need to be bound to specific deployments, by default, <em>libostree</em> uses <code>/etc</code> while for files that are independent and that will be shared it uses <code>/var</code>.</p>
</div>
<div class="paragraph">
<p>There is a special case that I didn’t touch on so far: User and Group management. Users and Groups are usually configured in <code>/etc/passwd</code> and <code>/etc/groups</code> files, so they would be part of the “writable files associated with a specific deployment” which could make sense for “system users” that execute OS processes, but the problem is that admins could also potentially create additional “regular” (dynamic) users. Why is that a problem? For example, when you deploy for the first time a <em>libostree</em> OS you will have a <code>/etc/passwd</code> (“v1”) file. Imagine that an admin using that first deployment creates a new user “<em>luis</em>”, which will imply to write in <code>/etc/passwd`so it will become “v2". Now imagine that at the same time, I want to include a new system user as part of the <em>libostree</em> update. The conflict arises because the <em>libostree</em> update process (I’m not talking about modifications made by RPMs) does not write over the `/etc/passwd</code> v2 including the new system user, it would do it in the <code>/etc/passwd</code> file “v1” because that’s the one that it finds in the chroot OS snapshot. What it will do in fact is to check the status of the <code>/etc</code> files, and then it will find that <code>/etc/passwd</code> has been modified from the “template” version (v1), so it will maintain that version (v2), making it impossible to include additional system users if someone modifies the <code>/etc/passwd</code> file (same for groups in <code>/etc/groups</code>). what could be done here?, <em>libostree</em> does not impose a solution for this corner case, but in Fedora/RHEL distros you find a possible solution: <a href="https://github.com/aperezdc/nss-altfiles"><em>nss-altfiles</em></a> . This piece of Software permits to include of additional files describing users and groups besides <code>/etc/passwd</code> and <code>/etc/groups</code>, so the solution is to create a file that will be bound to the system users in the chroot read-only filesystem (<code>/usr/lib/passwd</code> and <code>/usr/lib/groups</code> ) and use <a href="https://github.com/aperezdc/nss-altfiles"><em>nss-altfiles</em></a> to add that information to the ones described in <code>/etc/passwd</code> and <code>/etc/groups</code> which will hold the dynamic users created by admins.</p>
</div>
<div class="paragraph">
<p>Let’s forget about corner cases and go back to the simplicity of writable directories “bound” or “not bound” to a deployment.</p>
</div>
<div class="paragraph">
<p>Now that we know that <code>/etc</code> is used to host files that are bound to specific deployments, and in`/var` there are files that are independent, we can easily understand what happens with those directories when a new deployment is created by libostree: the <code>/etc</code> location is copied, so when it performs a <em>dnf</em> install (if you are using <em>rpm-ostree</em>), which could potentially change the config file format, it will modify the new copy associated with the new deployment, and let the old one untouched. At the same time, <code>/var</code> is just shared between them so the same files are accessible in both deployments.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*iowVb-fK_NEpWmiJVCImoQ.png" alt="Directories transition between different libostree deployments">
</div>
</div>
<div class="paragraph">
<p>Each libostree Operating System can decide what to put on <code>/var</code>, but it’s a good idea to include there the users' home directory (traditionally <code>/home</code>) so they can write and keep their cat pictures downloaded from Internet. We can take a look at the directory distribution in RHEL for Edge as an example, and compare it with the non-<em>libostree</em> (“regular”) RHEL directory tree (check out the “new” tag for changes):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*Zu78tuQFW90rPPMkxrPcSg.png" alt="RHEL for Edge directory tree">
</div>
</div>
<div class="paragraph">
<p>We can see here how <code>/usr</code> is mounted as read-only and. In order to maintain the common Linux directory structure, several links were created to the new location (in <code>/usr</code>), I’m talking about directories such as <code>/lib</code> or <code>/sbin</code>. You can also check that <code>/etc</code> and <code>/var</code> have write access and how <code>/home</code> or <code>/root</code> are redirected to <code>/var</code> along with other directories that contain files that are “independent” from the OS deployment.</p>
</div>
<div class="paragraph">
<p>The rest of the directories are “special” locations that you can find in Linux distros, but you can also find a new <code>/sysroot</code> directory along with a new <code>/ostree</code> link. As we saw, our root directory tree is in fact a <em>chroot jail</em>, which means that your <code>/</code> “virtual” directory tree is in fact hosted “physically” somewhere else (along with other <code>/</code> from different deployments). That “real” place where the different chroot directories are holded is <code>/sysroot</code>, in fact, if you check the screen captures that I included above to demonstrate the different OS deployments using chroot, you will see that they are placed in <code>/sysroot/ostree`and that’s also why the `/sysroot</code> directory on each deployment chroot directory is empty (because it must “really exist” on the system, outside the <em>chroot jail</em>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_i_should_have_included_a_tldr_in_thisarticle"><a class="anchor" href="#_i_should_have_included_a_tldr_in_thisarticle"></a>I should have included a TL/DR in this article…</h2>
<div class="sectionbody">
<div class="paragraph">
<p>…although if you have read all this “stuff” until this point, you probably don’t mind if I add a quick summary here.</p>
</div>
<div class="paragraph">
<p>We have seen how there was a need for a quick way to “fork” the Operating System (including data and Hardware device access), where you could rollback to the original version easily. They need that in order to develop and test Software that could break the system in a safe manner. After exploring multiple alternatives (virtualization, containers, etc) it was clear that a new way of managing the OS lifecycle needed to be created because the alternatives didn’t cover all the gaps.</p>
</div>
<div class="paragraph">
<p>One idea started taking form: What if we manage the Operating System following the same Git concept as if it were a source code repository where you can fork, roll back, track changes, etc… ?</p>
</div>
<div class="paragraph">
<p>Once the idea was clear it was only needed to choose the right Linux main technologies and features that would permit to implement the Git concept for the OS lifecycle management, and the answer was: c<em>hroot</em> and file hard-links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span id="aa92"><em>chroot</em> to isolate the different OS root filesystems (forks)</span></p>
</li>
<li>
<p><span id="e7b3">File hard-links to avoid file duplicates between the different OS root filesystems (limiting the impact of cross-changes due to linking with read-only filesystems)</span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With those components as the foundation, a new approach to the OS update lifecycle was created, and the new technology was called <em>libostree</em>, also known as <em>OSTree</em>.</p>
</div>
<div class="paragraph">
<p><em>Libostree</em> is a new system for versioning updates of Linux-based Operating Systems which brings several benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span id="dc4b">You can perform transactional upgrades (which can be done incrementally over HTTP)</span></p>
</li>
<li>
<p><span id="1260">You can perform rollback for the Operating System (including auto-rollback if something is not working after the update)</span></p>
</li>
<li>
<p><span id="1a5c">You can centralize the image generation, which provides OS consistency across multiple systems and also reduces the amount of computing power and network bandwidth needed to install Software packages (with <em>rpm-ostree</em>)</span></p>
</li>
<li>
<p><span id="f312">You can have prepared multiple OS deployments (parallel installs) where you can boot at anytime</span></p>
</li>
<li>
<p><span id="f92b">You have a track of changes thanks to a versioning system inspired by Git source-code repositories</span></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_but_why_a_libostree_os_could_be_interesting_tome"><a class="anchor" href="#_but_why_a_libostree_os_could_be_interesting_tome"></a>But why a libostree OS could be interesting to me?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I know that you like to learn new things to expand your mind and wisdom, but let’s focus just for a moment on the practical side of the <em>libostree</em> / <em>OSTree</em> concept. We have seen the benefits but, how is it relevant for any business/technical use case?</p>
</div>
<div class="paragraph">
<p>The benefits that you get out of a libostree OS could be applied to multiple use cases, but let’s focus on two of them.</p>
</div>
<div class="paragraph">
<p><strong>Container-focused Operating System</strong></p>
</div>
<div class="paragraph">
<p>Maybe you have realized that the way that we perform updates and rollbacks in a <em>libostree</em>-based OS is similar to what you do with containers, where you can use different container images versions from the container image registry, selected based on labels, and that you update by performing “a restart”. But there is more, the architecture is also similar since both boots from read-only disk and keep user data on different volumes.</p>
</div>
<div class="paragraph">
<p>The lifecycle of both have similarities and the good side is that with <em>libostree</em>-based systems that are running “only” containers you could completely split the lifecycle of the applications (containers) from the lifecycle of the OS, but at the same time you can follow the same practices for both.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Note: As you can imagine, eventhough both tradicional and containerized workloads can be executed, containers are preferred since they have an independent life-cycle from the current Operating System image deployed.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>For those reasons, you find <em>libostree</em> Operating Systems such as Fedora/https://docs.openshift.com/container-platform/4.11/architecture/architecture-rhcos.html[RHEL CoreOS], which is used as the Operating System that hosts the <a href="https://www.redhat.com/en/technologies/cloud-computing/openshift/container-platform">OpenShift Container Platform</a>.</p>
</div>
<div class="paragraph">
<p><strong>Edge computing</strong></p>
</div>
<div class="paragraph">
<p>This is another interesting use case. In a previous article relative to <a href="https://fidoalliance.org/intro-to-fido-device-onboard/">FIDO device onboarding (FDO)</a> feature (link below), which is quite interesting for Edge Computing use cases and which is available on RHEL, I introduced some common aspects that you find in an Edge computing solution architecture.</p>
</div>
<div class="paragraph">
<p><a href="https://luis-javier-arizmendi-alonso.medium.com/edge-computing-device-onboarding-part-i-introducing-the-challenge-59add9a86200"><strong>Edge Computing device onboarding — Part I— Introducing the challenge</strong><br>
<em>This article outlines the challenges that you will face while performing a secure device onboarding at the scale…</em>luis-javier-arizmendi-alonso.medium.com</a>https://luis-javier-arizmendi-alonso.medium.com/edge-computing-device-onboarding-part-i-introducing-the-challenge-59add9a86200[]</p>
</div>
<div class="paragraph">
<p>I will copy-paste that list here:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span id="f5f2">It will be capable of working in small HW footprint environments</span></p>
</li>
<li>
<p><span id="4f23">It will work at big scale</span></p>
</li>
<li>
<p><span id="6300">It will tolerate network disruption (or being disconnected)</span></p>
</li>
<li>
<p><span id="3f5d">It will be fully automated with a central point of management and observability</span></p>
</li>
<li>
<p><span id="898b">I will secure data at rest and in transit (even against physical threats)</span></p>
</li>
<li>
<p><span id="b3a0">I will be able to be integrated with external IT and OT systems and protocols</span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you paid attention to the benefits stated about <em>libostree</em>, you probably can see how some of its features are the perfect match to cover the needs of Edge Computing architectures. Just as a quick example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span id="2792">Updates are atomic and are done incrementally, only downloading the differences, so it provides better usage of the computing power and network bandwidth that are essential to reduce resource consumption at edge locations (not-good-enough networks, small HW footprint environments, …)</span></p>
</li>
<li>
<p><span id="af89">You also get less resource consumption (compute and network) while installing or updating Software packages, since as we saw, all the dependency calculations, %post scripts executing, SELabeling, and repository downloading are done once at the central site, opposite to having to perform the same task one time per system (which could be huge in Edge Computing environments) in locations where network and compute power capabilities are not the someones that you could find in a Data Center.</span></p>
</li>
<li>
<p><span id="5c92">When you work at scale you would like to have a consistent platform where you don’t have different Software versions in different locations on systems that should perform the same task. You get this out-of-the-box thanks to the usage of OS images (<em>libostree</em> commits) that can be distributed both online or offline to the edge locations. And it is not just consistency, the usage of images also gives you better reproducibility.</span></p>
</li>
<li>
<p><span id="1211">Probably in the Edge Computing remote locations, there are no specialized people that could install or perform troubleshooting of the devices (more about this in the FDO article above), so having a system that you can update and, if something starts failing, you could rollback either manually or automatically is a great advantage</span></p>
</li>
<li>
<p><span id="bfab">Although it is not something exclusively of Edge Computing environments, when you work at that scale is quite beneficial to get the change tracking capabilities that a Git-like system provides</span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These are some of the points why the usage of <em>libostree</em> Operating Systems as the base systems on Edge Computing devices is a good idea, and for example, <a href="https://docs.ota.here.com/ota-client/latest/comparing-full-filesystem-update-strategies.html">it is why some embedded systems manufacturers are moving away from old “dual-bank” architectures and providing <em>libostree</em> devices.</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_im_convinced_how_can_i_play_with_a_libostree_os"><a class="anchor" href="#_im_convinced_how_can_i_play_with_a_libostree_os"></a>I’m convinced, how can I play with a libostree OS?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Good!, I will give you two options here.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Note: If you have OpenShift probably it is not a good idea to start playing with CoreOS since the whole management of the Operating System is performed by OpenShift</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>The first one is going to <a href="https://getfedora.org/" class="bare">https://getfedora.org/</a> and choosing any of the editions that I marked with a red square below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://cdn-images-1.medium.com/max/800/1*yRGSr5JNxnuefLobNOAKDw.png" alt="Fedora editions based on libostree">
</div>
</div>
<div class="paragraph">
<p>For example, in my case, I’m running <a href="https://silverblue.fedoraproject.org/">Fedora Silverblue</a> on my laptop, and to be honest, the rollback functionality was super-useful. I will share a personal experience. One time I updated my laptop during the afternoon while the next morning (9 am) I had an important meeting…. Imagine what, my NVIDIA drivers decided to prevent the OS start. I couldn’t imagine that because it was the first time that something was not working after an update in Fedora (I don’t have the same experience with other distros), but what I did then is rollback to my previous deployment (before updating and where my NVIDIA drivers were still working), deliver a successful presentation and after that, when I had time, I fixed the issue to make my system work again with the new update.</p>
</div>
<div class="paragraph">
<p>I suggest trying Fedora Silverblue as the first step since Fedora IoT is kind of special since you need to perform additional steps to get your image ready to be used.. this can make it your second libostree distro to be tested.</p>
</div>
<div class="paragraph">
<p>But if you want to go with an option more “Enterprise ready” I would suggest checking <a href="https://www.redhat.com/en/resources/meet-workload-demands-edge-computing-datasheet">RHEL for Edge</a> which actually is similar to Fedora IoT but where you own the Image building process too, so you can also learn about it.</p>
</div>
<div class="paragraph">
<p>You could start from the <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/composing_installing_and_managing_rhel_for_edge_images/introducing-rhel-for-edge-images_composing-installing-managing-rhel-for-edge-images">official docs</a> but if you want a quick ramp-up you could use the “quick-start” scripts that I created (link below) to simplify the RHEL for Edge image creation.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/luisarizmendi/rhel-edge-quickstart"><strong>GitHub - luisarizmendi/rhel-edge-quickstart</strong><br>
<em>These scripts help to quickly create and publish RHEL for Edge images. You should execute them in a RHEL 9 server which…</em>github.com</a>https://github.com/luisarizmendi/rhel-edge-quickstart[]</p>
</div>
<div class="paragraph">
<p>That’s all!</p>
</div>
<div class="paragraph">
<p>I hope that you enjoyed reading this long article and that you cannot wait to start exploring the libostree OS benefits on your own.</p>
</div>
<div class="paragraph">
<p>Thanks for reading.</p>
</div>
<div class="paragraph">
<p>By <a href="https://medium.com/@luis-javier-arizmendi-alonso">Luis Javier Arizmendi Alonso</a> on <a href="https://medium.com/p/d84211e97933">August 25, 2022</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://medium.com/@luis-javier-arizmendi-alonso/a-git-like-linux-operating-system-d84211e97933">Canonical link</a></p>
</div>
<div class="paragraph">
<p>Exported from <a href="https://medium.com">Medium</a> on November 30, 2022.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="01-fdo-lab.html" class="query-params-link">1.b FDO - Lab</a></span>
  <span class="next"><a href="02-rfe-lab.html" class="query-params-link">2.b RHEL OSTree image - Lab</a></span>
</nav>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <a class="rhd-logo" href="https://developers.redhat.com" target="_blank"></div>
</footer>
<script src="../_/js/vendor/clipboard.js"></script>
<script src="../_/js/site.js"></script>
<script async src="../_/js/vendor/highlight.js"></script>
  </body>
</html>
